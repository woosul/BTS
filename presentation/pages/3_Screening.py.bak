"""
BTS 종목선정 페이지

KRW/BTC 시장에서 투자 가치가 높은 종목을 선정
"""
import streamlit as st
import sys
from pathlib import Path
import pandas as pd
from datetime import datetime

# 프로젝트 루트 추가
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from application.services.screening_service import ScreeningService
from infrastructure.exchanges.upbit_client import UpbitClient
from infrastructure.repositories.pinned_symbol_repository import PinnedSymbolRepository
from utils.logger import get_logger
from presentation.components.strategy_card import render_strategy_card
from presentation.components.strategy_modal import show_strategy_config_modal

logger = get_logger(__name__)

st.set_page_config(
    page_title="종목선정 - BTS",
    page_icon="",
    layout="wide"
)

# 사이드바 로고 설정
# 사이드바 로고 설정
logo_path = str(project_root / "resource" / "image" / "peaknine_logo_01.svg")
icon_path = str(project_root / "resource" / "image" / "peaknine_02.png")
st.logo(
    image=logo_path,
    icon_image=logo_path
)

# 로고 크기 조정 및 메뉴 스타일
st.markdown("""
<style>
    /* Noto Sans KR 폰트 로드 */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');
    /* Bootstrap Icons 로드 */
    @import url('https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css');
    /* Material Icons 로드 */
    @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200');

    /* 전체 폰트 적용 (아이콘 제외) */
    html, body, [class*="css"] {
        font-family: 'Noto Sans KR', sans-serif !important;
    }

    /* Streamlit 내부 요소 폰트 적용 */
    p, h1, h2, h3, h4, h5, h6, label, input, textarea, select, button,
    [data-testid] div, [data-testid] span, [data-testid] p,
    .stMarkdown, .stText, .stCaption {
        font-family: 'Noto Sans KR', sans-serif !important;
    }

    /* Material Icons 요소는 원래 폰트 유지 */
    .material-symbols-outlined,
    [class*="material-icons"],
    span[data-testid*="stIcon"],
    button span,
    [role="button"] span {
        font-family: 'Material Symbols Outlined', 'Material Icons' !important;
    }

    [data-testid="stSidebarNav"] {
        padding-top: 0 !important;
    }
    [data-testid="stSidebarNav"] > div:first-child {
        padding: 1.5rem 1rem !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        width: 100% !important;
    }
    [data-testid="stSidebarNav"] a {
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        width: 100% !important;
    }
    [data-testid="stSidebarNav"] img {
        width: 90% !important;
        max-width: 280px !important;
        height: auto !important;
    }
    [data-testid="stSidebarNav"] ul {
        margin-top: 1rem !important;
    }
    [data-testid="stSidebarNav"] ul li a {
        text-align: left !important;
        justify-content: flex-start !important;
    }
</style>
""", unsafe_allow_html=True)

def get_services():
    """서비스 인스턴스 가져오기"""
    if 'db' not in st.session_state:
        from infrastructure.database.connection import SessionLocal
        st.session_state.db = SessionLocal()

    if 'screening_service' not in st.session_state:
        exchange = UpbitClient()
        st.session_state.screening_service = ScreeningService(st.session_state.db, exchange)

    if 'pinned_repo' not in st.session_state:
        st.session_state.pinned_repo = PinnedSymbolRepository(st.session_state.db)

    return st.session_state.screening_service, st.session_state.pinned_repo

def main():
    # 전체 페이지 스타일 조정
    st.markdown("""
    <style>
    /* 타이틀 크기 조정 */
    h1 {
        font-size: 1.8rem !important;
        margin-top: 0.5rem !important;
        margin-bottom: 0.5rem !important;
    }
    h2 {
        font-size: 1.3rem !important;
        margin-top: 0.8rem !important;
        margin-bottom: 0.5rem !important;
    }
    h3 {
        font-size: 1.1rem !important;
        margin-top: 0.6rem !important;
        margin-bottom: 0.4rem !important;
    }
    /* 구분선 여백 조정 */
    hr {
        margin-top: 0.8rem !important;
        margin-bottom: 0.8rem !important;
    }
    /* 블록 요소 여백 조정 */
    .block-container {
        padding-top: 2rem !important;
        padding-bottom: 1rem !important;
    }

    /* 셀렉트박스 폰트 크기 및 스타일 */
    [data-baseweb="select"] > div {
        font-size: 0.875em !important;
    }
    [data-baseweb="select"] input {
        font-size: 0.875em !important;
    }
    [data-baseweb="select"] div[role="button"] {
        border-radius: 4px !important;
    }

    /* 사이드바 메뉴 스타일 */
    [data-testid="stSidebarNav"] ul li a {
        background-color: var(--primary-color) !important;
        border-radius: 4px !important;
        margin-bottom: 4px !important;
    }
    </style>
    """, unsafe_allow_html=True)

    st.markdown("<h1>종목선정</h1>", unsafe_allow_html=True)
    st.markdown("<hr style='margin: 0.5rem 0;'>", unsafe_allow_html=True)

    # 서비스 초기화
    screening_service, pinned_repo = get_services()

    # 사이드바: 스크리닝 설정
    with st.sidebar:
        st.markdown("<h3 style='margin-bottom: 0.8rem;'>스크리닝 설정</h3>", unsafe_allow_html=True)

        # 시장 및 전략 선택 (한 줄에 배치)
        col1, col2 = st.columns(2)

        with col1:
            market = st.selectbox(
                "시장",
                options=["KRW", "BTC"],
                help="**대상 시장**\n\n거래할 시장을 선택합니다.\n- KRW: 원화 시장\n- BTC: 비트코인 시장"
            )

        with col2:
            strategy_type = st.selectbox(
                "전략",
                options=["momentum", "volume", "technical", "hybrid"],
                format_func=lambda x: {
                    "momentum": "모멘텀 기반",
                    "volume": "거래량 기반",
                    "technical": "기술지표 복합",
                    "hybrid": "하이브리드"
                }[x],
                help="**스크리닝 전략**\n\n종목을 선정할 전략을 선택합니다.\n- 모멘텀: 가격/거래량 상승세\n- 거래량: 거래 활발도\n- 기술지표: RSI/MACD/MA 복합\n- 하이브리드: 여러 전략 조합"
            )

        # 시장의 전체 종목 수 미리 조회 (대략적인 수)
        try:
            from infrastructure.exchanges.upbit_client import UpbitClient
            temp_exchange = UpbitClient()
            market_symbols = temp_exchange.get_market_symbols(market)
            total_symbols = len(market_symbols)
            # 5의 배수로 올림
            max_symbols = ((total_symbols + 4) // 5) * 5
        except:
            total_symbols = 200
            max_symbols = 200

        # 상위 종목 수
        st.markdown("""
        <style>
        /* All 토글 우측 정렬 - padding 기반 정렬 */
        .st-key-show_all_toggle {
            margin-left: auto !important;
            display: block !important;
            padding-top: 0.3rem !important;
        }
        div[data-testid="column"]:nth-child(3) div[data-testid="stVerticalBlock"] {
            display: flex !important;
            justify-content: flex-end !important;
        }
        </style>
        """, unsafe_allow_html=True)

        col1, col2, col3 = st.columns([0.3, 0.4, 0.3])
        with col1:
            st.markdown("<h3 style='margin: 0; padding-top: 0.3rem;'>선정 종목 수</h3>", unsafe_allow_html=True)
        with col2:
            st.write("")  # 빈 공간
        with col3:
            show_all = st.toggle(
                "All",
                value=False,
                help="**전체 종목 표시**\n\n활성화 시 스크리닝 결과를 전체 종목으로 표시합니다.\n- ON: 모든 종목 표시\n- OFF: 상위 N개만 표시",
                key="show_all_toggle"
            )

        if show_all:
            st.info(f"전체 종목을 표시합니다 (총 {total_symbols}개)")
            top_n = total_symbols
        else:
            top_n = st.slider(
                "상위 종목",
                min_value=5,
                max_value=max_symbols,
                value=10,
                step=5,
                help=f"**상위 종목 수 설정**\n\n스크리닝 결과에서 상위 N개 종목만 선정합니다.\n- 최소: 5개\n- 최대: {max_symbols}개\n- 단위: 5개",
                label_visibility="collapsed"
            )
            st.caption(f"상위 {top_n}개 종목 (전체 {total_symbols}개 중)")

        st.markdown("<hr style='margin: 0.8rem 0;'>", unsafe_allow_html=True)

        # 스크리닝 실행 버튼
        run_screening = st.button(
            "스크리닝 실행",
            type="primary",
            use_container_width=True,
            help="설정된 전략으로 종목 스크리닝을 실행합니다"
        )

        st.markdown("<hr style='margin: 0.8rem 0;'>", unsafe_allow_html=True)

        # Session state 초기화
        if f"strategy_params_{strategy_type}" not in st.session_state:
            st.session_state[f"strategy_params_{strategy_type}"] = None

        # 현재 설정된 파라미터
        strategy_params = st.session_state.get(f"strategy_params_{strategy_type}")

        # 전략 이름 매핑
        strategy_names = {
            "momentum": "모멘텀 기반",
            "volume": "거래량 기반",
            "technical": "기술지표 복합",
            "hybrid": "하이브리드"
        }

        strategy_name = strategy_names.get(strategy_type, strategy_type)

        # 하이브리드 전략의 경우 개별 전략별 카드 표시
        if strategy_type == "hybrid" and strategy_params:
            weights = strategy_params.get("strategy_weights", {})

            # 모멘텀 카드
            if weights.get("momentum", 0) > 0:
                momentum_params = {
                    "price_weight": strategy_params.get("momentum_price_weight", 0.4),
                    "volume_weight": strategy_params.get("momentum_volume_weight", 0.3),
                    "rsi_weight": strategy_params.get("momentum_rsi_weight", 0.3),
                    "period_1d": strategy_params.get("momentum_period_1d", True),
                    "period_7d": strategy_params.get("momentum_period_7d", True),
                    "period_30d": strategy_params.get("momentum_period_30d", True)
                }
                render_strategy_card(
                    strategy_name=f"모멘텀 기반 | {weights.get('momentum', 0):.0%}",
                    strategy_type="momentum",
                    strategy_params=momentum_params,
                    card_key="hybrid_momentum",
                    show_button=False,
                    is_hybrid_sub=True
                )

            # 거래량 카드
            if weights.get("volume", 0) > 0:
                volume_params = {
                    "amount_weight": strategy_params.get("volume_amount_weight", 0.5),
                    "surge_weight": strategy_params.get("volume_surge_weight", 0.5),
                    "threshold": strategy_params.get("volume_threshold", 1.5),
                    "period": strategy_params.get("volume_period", 20)
                }
                render_strategy_card(
                    strategy_name=f"거래량 기반 | {weights.get('volume', 0):.0%}",
                    strategy_type="volume",
                    strategy_params=volume_params,
                    card_key="hybrid_volume",
                    show_button=False,
                    is_hybrid_sub=True
                )

            # 기술지표 카드
            if weights.get("technical", 0) > 0:
                technical_params = {
                    "rsi_weight": strategy_params.get("technical_rsi_weight", 0.3),
                    "macd_weight": strategy_params.get("technical_macd_weight", 0.4),
                    "ma_weight": strategy_params.get("technical_ma_weight", 0.3),
                    "use_rsi": strategy_params.get("technical_rsi", True),
                    "use_macd": strategy_params.get("technical_macd", True),
                    "use_ma": strategy_params.get("technical_ma", True),
                    "rsi_period": strategy_params.get("technical_rsi_period", 14),
                    "macd_fast": strategy_params.get("technical_macd_fast", 12),
                    "macd_slow": strategy_params.get("technical_macd_slow", 26),
                    "macd_signal": strategy_params.get("technical_macd_signal", 9),
                    "ma_short": strategy_params.get("technical_ma_short", 20),
                    "ma_long": strategy_params.get("technical_ma_long", 60)
                }
                render_strategy_card(
                    strategy_name=f"기술지표 복합 | {weights.get('technical', 0):.0%}",
                    strategy_type="technical",
                    strategy_params=technical_params,
                    card_key="hybrid_technical",
                    show_button=False,
                    is_hybrid_sub=True
                )

            # 하이브리드 설정 버튼
            button_clicked = st.button(
                f"{strategy_name} 설정",
                key=f"config_btn_{strategy_type}",
                use_container_width=True,
                type="primary" if not strategy_params else "secondary"
            )
        else:
            # 일반 전략 카드 렌더링
            button_clicked = render_strategy_card(
                strategy_name=strategy_name,
                strategy_type=strategy_type,
                strategy_params=strategy_params,
                card_key=strategy_type
            )

        # 설정 버튼 클릭 시 모달 열기
        if button_clicked:
            show_strategy_config_modal(
                strategy_name=strategy_name,
                strategy_type=strategy_type,
                current_params=strategy_params
            )

        # 설정되지 않은 경우 기본 파라미터 사용
        if not strategy_params:
            if strategy_type == "momentum":
                strategy_params = {
                    "price_weight": 0.4,
                    "volume_weight": 0.3,
                    "rsi_weight": 0.3,
                    "period_1d": True,
                    "period_7d": True,
                    "period_30d": True
                }
            elif strategy_type == "volume":
                strategy_params = {
                    "amount_weight": 0.5,
                    "surge_weight": 0.5,
                    "threshold": 1.5,
                    "period": 20
                }
            elif strategy_type == "technical":
                strategy_params = {
                    "rsi_weight": 0.3,
                    "macd_weight": 0.4,
                    "ma_weight": 0.3,
                    "use_rsi": True,
                    "use_macd": True,
                    "use_ma": True,
                    "rsi_period": 14,
                    "macd_fast": 12,
                    "macd_slow": 26,
                    "macd_signal": 9,
                    "ma_short": 20,
                    "ma_long": 60
                }
            elif strategy_type == "hybrid":
                strategy_params = {
                    "strategy_weights": {
                        "momentum": 0.40,
                        "volume": 0.30,
                        "technical": 0.30
                    },
                    "min_score": 0.5,
                    "momentum_price_weight": 0.4,
                    "momentum_volume_weight": 0.3,
                    "momentum_rsi_weight": 0.3,
                    "momentum_period_1d": True,
                    "momentum_period_7d": True,
                    "momentum_period_30d": True,
                    "volume_amount_weight": 0.5,
                    "volume_surge_weight": 0.5,
                    "volume_threshold": 1.5,
                    "volume_period": 20,
                    "technical_rsi_weight": 0.3,
                    "technical_macd_weight": 0.4,
                    "technical_ma_weight": 0.3,
                    "technical_rsi": True,
                    "technical_macd": True,
                    "technical_ma": True,
                    "technical_rsi_period": 14,
                    "technical_macd_fast": 12,
                    "technical_macd_slow": 26,
                    "technical_macd_signal": 9,
                    "technical_ma_short": 20,
                    "technical_ma_long": 60
                }

    # 메인 영역 - 항상 결과 페이지 표시

    # 스크리닝 실행 시 결과 업데이트
    if run_screening:
        with st.spinner("스크리닝 실행 중..."):
            try:
                # 스크리닝 실행
                results = screening_service.screen_symbols(
                    market=market,
                    strategy_type=strategy_type,
                    strategy_params=strategy_params,
                    top_n=top_n
                )

                # 결과 저장
                st.session_state.screening_results = results
                st.session_state.screening_market = market
                st.session_state.screening_strategy = strategy_type
                st.session_state.screening_time = datetime.now()
                st.success(f"스크리닝 완료: {len(results)}개 종목 선정")

            except Exception as e:
                logger.error(f"스크리닝 실패: {e}")
                st.error(f"스크리닝 실패: {e}")
                import traceback
                st.text(traceback.format_exc())

    # 결과 준비: 스크리닝 결과가 있으면 사용, 없으면 빈 리스트
    results = st.session_state.get('screening_results', [])

    # 제목 표시
    if results:
        st.markdown(f"<h3 style='margin-bottom: 10px;'>스크리닝 결과 (상위 {len(results)}개)</h3>", unsafe_allow_html=True)
    else:
        st.markdown("<h3 style='margin-bottom: 10px;'>종목 선정</h3>", unsafe_allow_html=True)
        st.info("스크리닝을 실행하거나 지정 종목을 추가하여 매수 분석을 시작하세요.")

    # 메타 정보 - 카드형 스타일
        st.markdown("""
        <style>
        .metric-card {
            background-color: #1E1E1E;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
            border: 1px solid #3d3d4a;
        }
        .metric-label {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 4px;
        }
        .metric-value {
            font-size: 1rem;
            font-weight: 600;
            color: #FAFAFA;
        }
        </style>
        """, unsafe_allow_html=True)

        col1, col2, col3 = st.columns(3)
        with col1:
            st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">시장</div>
                <div class="metric-value">{st.session_state.screening_market}</div>
            </div>
            """, unsafe_allow_html=True)
        with col2:
            strategy_name = {
                "momentum": "모멘텀",
                "volume": "거래량",
                "technical": "기술지표",
                "hybrid": "하이브리드"
            }.get(st.session_state.screening_strategy, "Unknown")
            st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">전략</div>
                <div class="metric-value">{strategy_name}</div>
            </div>
            """, unsafe_allow_html=True)
        with col3:
            st.markdown(f"""
            <div class="metric-card">
                <div class="metric-label">실행 시간</div>
                <div class="metric-value">{st.session_state.screening_time.strftime("%H:%M:%S")}</div>
            </div>
            """, unsafe_allow_html=True)

        st.markdown("<div style='margin: 12px 0;'></div>", unsafe_allow_html=True)

        # 결과 테이블 - 타이틀과 버튼
        col_title, col_spacer, col_btn1, col_btn2, col_btn3 = st.columns([0.4, 0.15, 0.15, 0.15, 0.15])
        with col_title:
            st.markdown("<h3 style='margin: 0; padding-top: 0.3rem;'>선정 종목</h3>", unsafe_allow_html=True)
        with col_btn1:
            save_pinned_btn = st.button("지정종목저장", use_container_width=True, type="secondary")
        with col_btn2:
            single_analysis_btn = st.button("단일매수분석", use_container_width=True, type="secondary")
        with col_btn3:
            if 'continuous_analysis_running' not in st.session_state:
                st.session_state.continuous_analysis_running = False

            if st.session_state.continuous_analysis_running:
                stop_analysis_btn = st.button("매수분석정지", use_container_width=True, type="primary")
                if stop_analysis_btn:
                    st.session_state.continuous_analysis_running = False
                    st.success("연속 매수 분석이 정지되었습니다.")
                    st.rerun()
            else:
                continuous_analysis_btn = st.button("연속매수분석", use_container_width=True, type="secondary")
                if continuous_analysis_btn:
                    st.session_state.continuous_analysis_running = True
                    st.success("연속 매수 분석이 시작되었습니다.")
                    st.rerun()

        st.markdown("<div style='margin: 0.8rem 0;'></div>", unsafe_allow_html=True)

        # 지정 종목 DB에서 로드
        if 'pinned_symbols' not in st.session_state or st.session_state.get('pinned_symbols_loaded') != market:
            db_pinned = pinned_repo.get_all_active(market=market)
            st.session_state.pinned_symbols = set([p.symbol for p in db_pinned])
            st.session_state.pinned_symbols_loaded = market

        # 현재 스크리닝 결과의 고유 키 생성
        screening_key = f"{market}_{strategy_type}_{st.session_state.get('screening_time', '')}"

        # DataFrame 생성 - 지정 종목과 일반 종목 분리
        pinned_data = []
        unpinned_data = []

        # 스크리닝 결과를 dict로 변환 (빠른 조회를 위해)
        results_dict = {r.symbol: r for r in results}

        # 1. 먼저 DB의 지정 종목을 처리 (스크리닝 결과에 없어도 표시)
        for symbol in st.session_state.pinned_symbols:
            if symbol in results_dict:
                result = results_dict[symbol]
                row = {
                    "종목": result.symbol,
                    "점수": result.score,
                    "순위": "✓"
                }
                # 세부 점수 추가
                for key, value in result.details.items():
                    if isinstance(value, (int, float)):
                        row[key] = value
                    else:
                        row[key] = str(value)
            else:
                # 스크리닝 결과에 없는 지정 종목 (이전에 지정했던 종목)
                row = {
                    "종목": symbol,
                    "점수": 0.0,
                    "순위": "✓"
                }
            pinned_data.append(row)

        # 2. 일반 종목 처리 (지정되지 않은 종목만)
        unpinned_rank = 1
        for result in results:
            if result.symbol not in st.session_state.pinned_symbols:
                row = {
                    "종목": result.symbol,
                    "점수": result.score,
                    "순위": unpinned_rank
                }
                unpinned_rank += 1

                # 세부 점수 추가
                for key, value in result.details.items():
                    if isinstance(value, (int, float)):
                        row[key] = value
                    else:
                        row[key] = str(value)

                unpinned_data.append(row)

        # 지정 종목을 상단에, 일반 종목을 하단에 배치
        data = pinned_data + unpinned_data
        df = pd.DataFrame(data)

        # 숫자형 컬럼 식별
        numeric_columns = df.select_dtypes(include=['float64', 'int64']).columns

        # 컬럼 순서를 재배열하기 위한 새로운 DataFrame 구성
        new_columns = ["순위", "종목"]

        for col in numeric_columns:
            if col not in ["순위"]:  # 전체 순위 컬럼은 제외
                # 순위 계산 (내림차순 - 높은 값이 좋음)
                # NaN 값 처리: NaN은 순위 계산에서 제외하고, 나중에 빈 문자열로 대체
                rank_col = f"{col}_R"
                df[rank_col] = df[col].rank(ascending=False, method='min', na_option='keep')
                # NaN이 아닌 값만 int로 변환, NaN은 유지
                df[rank_col] = df[rank_col].apply(lambda x: int(x) if pd.notna(x) else None)

                # 값 컬럼과 순위 컬럼을 순서대로 추가
                new_columns.append(col)
                new_columns.append(rank_col)

        # 문자열 컬럼 추가 (순위가 없는 컬럼들)
        for col in df.columns:
            if col not in new_columns and col not in numeric_columns:
                new_columns.append(col)

        # 컬럼 순서 재배열
        df = df[new_columns]

        # 전체 컬럼 수 계산하여 동적 width 설정
        total_cols = len(df.columns)

        # 1-5위 순위를 강조하기 위해 텍스트로 변환
        display_df = df.copy()
        for col in df.columns:
            if col.endswith("_R"):
                # 1-5위는 "1 ●", "2 ●" 형식으로 표시, None은 빈 문자열
                display_df[col] = df[col].apply(
                    lambda x: f"{int(x)} ●" if pd.notna(x) and x <= 5 else (str(int(x)) if pd.notna(x) else "")
                )

        # 동적으로 컬럼 너비 계산
        # 전체 컬럼 수에 따라 값 컬럼과 R 컬럼 너비 조정
        num_value_cols = len([c for c in df.columns if c not in ["순위", "종목"] and not c.endswith("_R")])

        # 고정 컬럼: 순위(60px), 종목(120px)
        # R 컬럼: 40px
        # 나머지를 값 컬럼들이 균등 분배

        # 컬럼 설정
        column_config = {}
        for col in display_df.columns:
            if col == "순위":
                column_config[col] = st.column_config.NumberColumn(
                    col,
                    width=60
                )
            elif col == "종목":
                column_config[col] = st.column_config.TextColumn(
                    col,
                    width=100
                )
            elif col.endswith("_R"):
                # 순위 컬럼 - "R"로 표시
                column_config[col] = st.column_config.TextColumn(
                    "R",
                    width=45
                )
            elif col in numeric_columns and col != "순위":
                column_config[col] = st.column_config.NumberColumn(
                    col,
                    width=90,
                    format="%.2f"
                )

        # 데이터 표시 및 Row 선택 - dataframe 사용
        event = st.dataframe(
            display_df,
            use_container_width=True,
            hide_index=True,
            height=400,
            column_config=column_config,
            on_select="rerun",
            selection_mode="single-row",
            key="screening_results_grid"
        )

        # Row 선택 시 상세 정보에 사용할 종목 저장
        if event.selection and event.selection.rows:
            selected_row_idx = event.selection.rows[0]
            st.session_state.selected_symbol_from_grid = display_df.iloc[selected_row_idx]["종목"]

        # 지정 종목 편집을 위한 멀티셀렉트
        st.markdown("<div style='margin: 0.5rem 0;'></div>", unsafe_allow_html=True)

        # 현재 지정된 종목 목록 표시
        current_pinned = list(st.session_state.pinned_symbols)

        # 스크리닝 결과 종목과 지정 종목을 합쳐서 options 생성 (중복 제거)
        all_symbols = list(set([r.symbol for r in results] + current_pinned))
        all_symbols.sort()  # 정렬

        new_pinned_list = st.multiselect(
            "지정 종목 관리 (추가/제거)",
            options=all_symbols,
            default=current_pinned,
            key="pinned_symbols_multiselect",
            help="지정 종목을 선택/해제하세요. 지정 종목은 스크리닝 결과와 무관하게 유지됩니다."
        )

        # 지정 종목 변경 감지 및 DB 동기화
        new_pinned_symbols = set(new_pinned_list)
        if new_pinned_symbols != st.session_state.pinned_symbols:
            # 추가된 종목
            added = new_pinned_symbols - st.session_state.pinned_symbols
            for symbol in added:
                pinned_repo.add(symbol, market)

            # 제거된 종목
            removed = st.session_state.pinned_symbols - new_pinned_symbols
            for symbol in removed:
                pinned_repo.remove(symbol)

            st.session_state.pinned_symbols = new_pinned_symbols
            st.rerun()

        # 지정종목저장 버튼 처리
        if save_pinned_btn:
            if st.session_state.pinned_symbols:
                st.success(f"{len(st.session_state.pinned_symbols)}개의 지정 종목이 DB에 저장되었습니다.")
                st.info("지정 종목: " + ", ".join(st.session_state.pinned_symbols))
            else:
                st.warning("지정된 종목이 없습니다.")

        # 다운로드 버튼
        csv = df.to_csv(index=False, encoding='utf-8-sig')
        st.download_button(
            label="CSV 다운로드",
            data=csv,
            file_name=f"screening_{st.session_state.screening_market}_{st.session_state.screening_time.strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )

        st.markdown("<hr style='margin: 1rem 0;'>", unsafe_allow_html=True)

        # 상세 정보
        st.markdown("<h3 style='margin: 0; padding-top: 0.3rem;'>종목 상세 정보</h3>", unsafe_allow_html=True)

        # Row 선택된 종목이 있으면 해당 종목의 상세 정보 표시
        selected_symbol = st.session_state.get('selected_symbol_from_grid')

        if not selected_symbol:
            st.info("그리드에서 종목을 선택하면 상세 정보가 표시됩니다.")
        else:
            selected_result = next(r for r in results if r.symbol == selected_symbol)

            col1, col2 = st.columns(2)

            with col1:
                st.write("**기본 정보**")
                st.write(f"- 종목: {selected_result.symbol}")
                st.write(f"- 총점: {selected_result.score:.2f}")
                st.write(f"- 평가 시간: {selected_result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}")

            with col2:
                st.write("**세부 점수**")

                # 숫자형 세부 점수만 추출
                numeric_scores = {}
                for key, value in selected_result.details.items():
                    if isinstance(value, (int, float)):
                        numeric_scores[key] = value

                if numeric_scores:
                    # Radar chart 생성
                    import plotly.graph_objects as go

                    categories = list(numeric_scores.keys())
                    values = list(numeric_scores.values())

                    # 극단값 처리: IQR 방식으로 아웃라이어 제한
                    if values and len(values) > 3:
                        import numpy as np
                        q1 = np.percentile(values, 25)
                        q3 = np.percentile(values, 75)
                        iqr = q3 - q1
                        # 상한값: Q3 + 1.5 * IQR
                        upper_bound = q3 + 1.5 * iqr

                        # 극단값을 상한값으로 제한
                        capped_values = [min(v, upper_bound) for v in values]
                        # radial axis 범위 설정
                        max_range = upper_bound * 1.1
                    elif values:
                        capped_values = values
                        max_range = max(values) * 1.1 if values else 100
                    else:
                        capped_values = values
                        max_range = 100

                    fig = go.Figure()

                    fig.add_trace(go.Scatterpolar(
                        r=capped_values,
                        theta=categories,
                        fill='toself',
                        name=selected_result.symbol,
                        line=dict(color='#54A0FD'),
                        fillcolor='rgba(84, 160, 253, 0.3)'
                    ))

                    fig.update_layout(
                        polar=dict(
                            bgcolor='#262730',
                            radialaxis=dict(
                                visible=True,
                                range=[0, max_range],
                                gridcolor='#3d3d4a',
                                linecolor='#3d3d4a'
                            ),
                            angularaxis=dict(
                                gridcolor='#3d3d4a',
                                linecolor='#3d3d4a',
                                color='#FAFAFA'
                            )
                        ),
                        showlegend=False,
                        height=400,
                        margin=dict(l=80, r=80, t=40, b=40),
                        paper_bgcolor='rgba(0,0,0,0)',
                        plot_bgcolor='rgba(0,0,0,0)',
                        font=dict(color='#FAFAFA')
                    )

                    st.plotly_chart(fig, use_container_width=True)

                # 비숫자형 항목은 텍스트로 표시
                non_numeric = {k: v for k, v in selected_result.details.items()
                              if not isinstance(v, (int, float))}
                if non_numeric:
                    st.write("**기타 정보**")
                    for key, value in non_numeric.items():
                        st.write(f"- {key}: {value}")

    else:
        # 초기 화면
        st.info(
            "왼쪽 사이드바에서 시장과 전략을 선택한 후 "
            "'스크리닝 실행' 버튼을 클릭하세요."
        )

        st.markdown("<hr style='margin: 1rem 0;'>", unsafe_allow_html=True)

        # 가이드
        st.markdown("<h3 style='margin-bottom: 0.8rem;'>스크리닝 전략 소개</h3>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("""
            **모멘텀 기반**
            - 가격 상승률
            - 거래량 증가율
            - RSI 모멘텀
            - 가중치 조합

            **거래량 기반**
            - 거래대금 순위
            - 거래량 급증 감지
            - 유동성 점수
            """)

        with col2:
            st.markdown("""
            **기술지표 복합**
            - RSI
            - MACD
            - 이동평균 정배열
            - 복합 지표 점수

            **하이브리드**
            - 여러 전략 조합
            - 전략별 가중치
            - 최적 조합 탐색
            """)

        st.markdown("<hr style='margin: 1rem 0;'>", unsafe_allow_html=True)

        st.markdown("<h3 style='margin-bottom: 0.8rem;'>사용 방법</h3>", unsafe_allow_html=True)

        st.markdown("""
        1. **시장 선택**: KRW 또는 BTC 시장
        2. **전략 선택**: 4가지 스크리닝 전략 중 선택
        3. **파라미터 설정**: 전략별 가중치 및 옵션 설정
        4. **스크리닝 실행**: 상위 N개 종목 자동 선정
        5. **결과 분석**: 선정된 종목의 점수 및 세부 정보 확인
        """)

        st.markdown("<hr style='margin: 1rem 0;'>", unsafe_allow_html=True)

        st.markdown("<h3 style='margin-bottom: 0.8rem;'>주의사항</h3>", unsafe_allow_html=True)

        st.markdown("""
        <div style='background-color: #40424890; border-left: 4px solid #00CCAC; padding: 16px; border-radius: 4px;'>
            <div style='font-size: 0.875rem; color: #FAFAFA; line-height: 1.6;'>
                • 스크리닝 결과는 투자 참고 자료일 뿐, 투자 결정의 근거가 될 수 없습니다<br>
                • 시장 상황에 따라 점수가 달라질 수 있습니다<br>
                • 여러 전략을 조합하여 사용하는 것을 권장합니다<br>
                • 백테스팅을 통해 전략의 유효성을 검증하세요
            </div>
        </div>
        """, unsafe_allow_html=True)

        st.markdown("<hr style='margin: 1rem 0;'>", unsafe_allow_html=True)

        # 전략 설명 가이드 (expander)
        with st.expander("📘 전략 설명 가이드", expanded=False):
            st.markdown("""
            ### 모멘텀 기반 전략
            가격과 거래량의 상승세를 기반으로 종목을 선정합니다.
            - **가격 모멘텀**: 1일/7일/30일 가격 상승률
            - **거래량 모멘텀**: 거래량 증가율
            - **RSI 모멘텀**: RSI 지표 변화

            **추천 상황**: 상승 추세 시장, 단기 트레이딩

            ---

            ### 거래량 기반 전략
            거래 활발도를 기준으로 종목을 선정합니다.
            - **거래대금**: 24시간 거래대금 순위
            - **거래량 급증**: 평균 대비 거래량 증가율
            - **유동성 점수**: 거래량/시가총액 비율

            **추천 상황**: 변동성 확대 구간, 신규 자금 유입 시

            ---

            ### 기술지표 복합 전략
            RSI, MACD, 이동평균선을 조합하여 종목을 선정합니다.
            - **RSI**: 과매도/과매수 구간 판단
            - **MACD**: 추세 전환 신호
            - **이동평균**: 골든/데드 크로스

            **추천 상황**: 추세 전환 예상 시점, 기술적 분석 선호

            ---

            ### 하이브리드 전략
            여러 전략을 가중치로 조합하여 종목을 선정합니다.
            - 각 전략별 점수를 계산
            - 가중치를 적용하여 종합 점수 산출
            - 복합적인 관점에서 종목 평가

            **추천 상황**: 안정적인 종목 선정, 리스크 분산
            """)

if __name__ == "__main__":
    main()
